module not (in) -> (out) {
    nor inv(a=in, b=in) -> (out);
}

module and(a, b) -> (out) {
    wire inva, invb;

    not not_a(in=a) -> (out=inva);
    not not_b(in=b) -> (out=invb);

    nor nor(a=inva, b=invb) -> (out);
}

module or(a, b) -> (out) {
    wire norab;
    nor ng(a, b) -> (out=norab);
    not inv(in=norab) -> (out);
}

module nand(a, b) -> (out) {
    wire andab;
    and and_(a, b) -> (out=andab);
    not inv(in=andab) -> (out);
}

module xnor(a, b) -> (out) {
    wire a_and_b, nor_a_b;
    and and(a, b) -> (out=a_and_b);
    nor nor(a, b) -> (out=nor_a_b);
    or or(a=a_and_b, b=nor_a_b) -> (out);
}

module xor(a, b) -> (out) {
    wire a_xnor_b;
    xnor xnor(a, b) -> (out=a_xnor_b);
    not not(in=a_xnor_b) -> (out);
}

module SRLatch(s, r) -> (q) {
    wire notq;
    nor nora(a=r, b=notq) -> (out=q);
    nor norb(a=s, b=q) -> (out=notq);
}

module DLatch(clk, d) -> (q) {
    wire s, r, invd;

    not not_d(in=d) -> (out=invd);

    and ands(a=d, b=clk) -> (out=s);
    and andr(a=invd, b=clk) -> (out=r);

    SRLatch sr(s=s, r=r) -> (q=q);
}

module DFlipFlop(clk, d) -> (q) {
    wire invclk;
    wire slaved;

    not not_clk(in=clk) -> (out=invclk);

    DLatch master(clk=invclk, d=d) -> (q=slaved);
    DLatch slave(clk, d=slaved) -> (q=q);
}

